"""
This class is in charge of:
1. Connecting and listening to peers.
2. Sending shares to peers.
3. Receiving shares from peers.

Example, for a case where there are 3 people in a party:
1. The server will open 4 threads.
2. 2 threads are for listening to the other two.
3. 2 threads are for sending to the other 2.

Note: This class uses the file generated by file_solve.py

Function Specifications:
1. Init: Retrieve client information (address, IP), keeps track of connected clients, starts the send and receive methods.
2. Receive: Allows acception of incoming connections, keeps track of current clients, and starts new communication threads.
3. Handle: Receives client data, and writes data. 
4. Send: Send file(s) and it's content to selected peer.
"""
import socket
import threading
from color_output import *
import os
import glob

class connect_to_peer:

    def __init__(self,command,client) -> None:
        #Retrieves local client information
        self.command=command
        client.information=client.getsockname()
        self.host = client[0]
        self.port = client[1]+1

        # Create the TCP socket and begin listening for incoming connections
        self.server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.server.bind((self.host, self.port))
        self.server.listen()
        print("Peer Server is listening on",self.host,":",self.port)

        #Keeps track of the current client list.
        self.client_list=[]

        self.receive()
        self.send()

    def receive(self):
        while True:
            try:
                #Ability to accept connections.
                client, address = self.server.accept()
                print(f"Connected to {str(address)}")

                #Add to list of active clients and starts a new thread.
                self.client_list.append(client)
                threading.Thread(target=self.handle, args=(client,)).start()
            except Exception as e:
                print("Error receiving connection: ", e)


    def handle(self,client):
        try: 
            calc, stats = self.command[1], self.command[2]
            file_name=str(calc)+"_"+str(stats)+"_"+len(self.client_list)+".txt"
            with open('../share_received/'+file_name,'w+') as f:
                while True:
                    l = client.recv(1024)
                    f.write(l.decode('ascii'))
            prCyan("Done receiving.")
        except Exception as e:
            print("Error in handling client data:", e)
        finally:
            client.close()


    def send(self):
        peer_lists = self.command[3]  # List of peers to send data to
        for peer in peer_lists:
            send_client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  
            try:
                send_client.connect((peer[0], peer[1]))
                #Maybe a print statement here for peer connection clarification
                file_name = "./share_to_send/" + str(self.command[1]) + "_" + str(self.command[2]) + "*.txt"
                file_to_send = glob.glob(file_name)
                if file_to_send:
                    with open(file_to_send[0]) as f:
                        print("Currently sending file: ", file_to_send)
                        l = f.read(1024)
                        while (l):
                            send_client.send(l.encode('ascii'))
                            l = f.read(1024)
                    os.remove(file_to_send[0])
            except Exception as e:
                print("Failed to send file.", e)   
            finally:
                send_client.close()
        prCyan("Done Sending All Shares")


                

