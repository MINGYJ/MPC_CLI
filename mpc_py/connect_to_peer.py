"""
This class is in charge of:
1. Connecting and listening to peers.
2. Sending shares to peers.

Example, for a case where there are 3 people in a party:
1. The server will open 4 threads.
2. 2 threads are for listening to the other two.
3. 2 threads are for sending to the other 2.

Note: This class uses the file generated by file_solve.py

Function Specifications:
1. Init: Retrieve client information (address, IP), keeps track of connected clients, starts the send and receive methods.
2. Receive: Allows the client to accept an incoming connection and be added to the client list.
3. Handle: Creates file name, receives client data, and writes data. 
4. Send: Send file(s) and it's content to selected peer.
"""
import socket
import threading
from color_output import *
import os
import glob

class connect_to_peer:

    def __init__(self,command,client) -> None:
        self.command=command
        client=client.getsockname()
        self.host = client[0]
        self.port = client[1]+1
        #port +1 to be share channel to avoid conflict with the server
        self.server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.server.bind((self.host, self.port))
        self.server.listen()
        print("Peer Server is listening on",self.host,":",self.port)
        self.client_list=[]
        self.receive()
        self.send()

    def receive(self):
        while True:
            client, address = self.server.accept()
            print(f"Connected with {str(address)}")
            print('Connected to the',client)
            #connect to client
            self.client_list.append(client)
            # Handling Multiple Clients Simultaneously
            thread = threading.Thread(target=self.handle, args=(client,))
            thread.start()

    def handle(self,client):
        while True:
            try:
                calc=self.command[1]
                stats=self.command[2]
                file_name=str(calc)+"_"+str(stats)+"_"+len(self.client_list)+".txt"
                f = open('../share_received/'+file_name,'w+')
                l = client.recv(1024)
                while (l):
                    f.write(l.decode('ascii'))
                    l = client.recv(1024)
                f.close()
                prCyan ("Done Receiving")
            except  Exception as e:
                print("Error in handle",e)
                break

    def send(self):
        # Send the file in share_to_send to every other people in the party
        peer_lists = self.command[3]  # List of peers to send data to
        for peer in peer_lists:
            send_client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  
            try:
                send_client.connect((peer[0], peer[1]))
                #Maybe a print statement here for peer connection clarification
                file_name = "./share_to_send/" + str(self.command[1]) + "_" + str(self.command[2]) + "*.txt"
                file_to_send = glob.glob(file_name)
                if file_to_send:
                    with open(file_to_send[0]) as f:
                        print("Currently sending file: ", file_to_send)
                        l = f.read(1024)
                        while (l):
                            send_client.send(l.encode('ascii'))
                            l = f.read(1024)
                    os.remove(file_to_send[0])
            except Exception as e:
                print("Failed to send file.", e)   
            finally:
                send_client.close()
        prCyan("Done Sending All Shares")


                

